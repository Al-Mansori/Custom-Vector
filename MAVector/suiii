#include <iostream>
#include <algorithm>
#include <string>
#include <vector>
#include <memory>
#include <stdlib.h>
#include <string_view>
using namespace std;

/**
 * @brief 
 * 
 * @tparam T 
 */
template<class T>
class MAVector {
private:
	int m_size = 0;
	int m_capacity = 0;
	T* Data = nullptr;
private:
	/// @brief delete data[i]
	void destroyAll() {
		for (size_t i = 0; i < size(); i++)
			Data[i].~T();
	}
public:
	using iterator = T*;
	MAVector() {
		reserve(2);
	}
	~MAVector() {
		clear();
		free(Data);
	}
	MAVector(T* t, int n) {
		reserve(n);
		for (size_t i = 0; i < n; i++)
			this->push_back(t[i]);
	}
	MAVector(int n) {
		reserve(n);
	}
	MAVector(const MAVector& vec) {
		reserve(vec.size());
		for (size_t i = 0; i < vec.size(); i++)
			this->push_back(vec.Data[i]);
	}
	/// @brief copy assignment operator 
	/// @param vec 
	/// @return just copying the vector
	MAVector& operator=(const MAVector& vec) {
		if (this->Data == vec.Data)
			return *this;
		
		clear();
		reserve(vec.size());
		for (size_t i = 0; i < vec.size(); i++)
			this->push_back(vec.Data[i]);


	}
	/// @brief move assignment operator 
	/// @param vec 
	/// @return making the vector pointing to another vector, making the other vector pointing to null
	MAVector& operator=(MAVector&& vec) {
		if (this->Data == vec.Data)
			return *this;

		destroyAll();
		free(Data);
		Data = move(vec.Data);
		vec.Data = nullptr;
		m_size = vec.m_size;
		m_capacity = vec.m_capacity;
		vec.m_capacity = 0;
		vec.m_size = 0;
		return *this;
	}
	/// @brief adjusting the size of the vector based on 3 cases
	/// case 1 : the new size is less than the current size
	/// case 2 : the new size is bigger than the capacity 
	/// case 3 : the new size is less than the capacity and bigger than the current size
	/// @param new_size 
	void resize(int new_size) {
		if (new_size < m_size) {
			for (size_t i = new_size; i < size(); i++)
				Data[i].~T();
			m_size = new_size;
		}
		else if (new_size > m_capacity) {
			T* newBlock = (T*)malloc((new_size) * sizeof(T));
			for (size_t i = 0; i < size(); i++)
				new(&newBlock[i])  T(move(Data[i]));

			for (size_t i = size(); i < new_size; i++)
				new(&newBlock[i])  T();

			destroyAll();
			if (Data != nullptr)
				free(Data);

			Data = move(newBlock);
			newBlock = nullptr;
			m_capacity = new_size;
			m_size = new_size;
		}
		else if (new_size < m_capacity) {
			for (size_t i = size(); i < new_size; i++)
				new(&Data[i])  T();
			
			m_size = new_size;
		}
	}
	/// @brief checking if the capacity is enough for the vector and preparing for the push back
	/// @param new_capacity 
	void reserve(int new_capacity) {
		if (m_capacity < new_capacity) {
			T* newBlock = (T*)malloc(new_capacity * sizeof(T));
			for (size_t i = 0; i < m_size; i++)
				new(&newBlock[i])  T(move(Data[i]));

			destroyAll();
			if (Data != nullptr)
				free(Data);

			Data = move(newBlock);
			newBlock = nullptr;
			m_capacity = new_capacity;
		}
	}
	/// @brief allocate new capacity from the memory, then add new index or object
	/// @param val 
	void push_back(const T& val) {
		if (m_size >= m_capacity)
			reserve(m_capacity * 2);
		new(&Data[m_size++]) T(val);
	}

	int size()  const { return m_size; }
	int capacity() const { return m_capacity; }
	bool empty() const { return m_size == 0; }
	T& operator[](int indx) {
		if (indx < 0 || indx >= m_size)
			throw std::out_of_range("Out of range");
		
		else
			return Data[indx];
	}
	/// @brief after checking that the vector is not empty, delete the last index or object
	/// then adjust the size -1
	/// @return 
	T pop_back() {
		if (empty()) {
			throw std::out_of_range("Empty vector!!");
		}
		T temp = move(Data[m_size - 1]);
		Data[m_size - 1].~T();
		m_size--;
		return temp;
	}
	/// @brief destroy + making the size = 0,
	void clear() {
		destroyAll();
		m_size = 0;
	}
	/// @brief insert object or index in the vector after checking it cannot be out of range
	/// @param t1 
	/// @param val 
	void insert(iterator t1, const T& val) {
		if (t1 > this->end() || t1 < this->begin()) {
			throw std::out_of_range("Out of range");
		}

		int new_size = m_size + 1;
		T* newBlock = (T*)malloc((new_size) * sizeof(T));
		int flag = 0;
		for (size_t i = 0; i < new_size; i++) {
			if ((Data + i) == t1) {
				new(&newBlock[i++]) T(val);
				flag++;
				new(&newBlock[i]) T(Data[i - flag]);

			}
			new(&newBlock[i])  T(move(Data[i - flag]));
		}

		destroyAll();
		free(Data);
		Data = move(newBlock);
		newBlock = nullptr;
		m_capacity = new_size;
		m_size = new_size;


	}
	/// @brief destroy any object or indext between iterators(1,2)
	/// @param t1 
	/// @param t2 
	void erase(iterator t1, iterator t2) {
		if (t1 > this->end() || t1 < this->begin() || t2 > this->end() || t2 < this->begin()) {
			throw std::out_of_range("Out of range");
		}

		destroy(t1, t2);
		auto dis = std::distance(t1, t2);
		for (auto itr = t1; itr != (this->end() - dis); itr++) {
			*(itr) = std::move(*(itr + dis));

		}
		m_size -= dis;
		//destroy(t1 + count, this->end())
	}
	/// @brief apply destroy for the vector if there is no out of range indexes
	///for destroying only on object or index
	/// @param t1 
	void erase(iterator t1) {
		if (t1 > this->end() || t1 < this->begin()) {
			throw std::out_of_range("Out of range");
		}

		std::destroy(t1, t1 + 1);
		auto dis = 1;
		for (auto itr = t1; itr != (this->end() - dis); itr++) {
			*(itr) = std::move(*(itr + dis));

		}
		m_size -= dis;
	}


	//erase by index & times
	/*void erase(int indx, int times) {
		for (size_t i = 0; i < times; i++)
			Data[indx + i].~T();
	}*/
	
	iterator begin() { return Data; }
	iterator end() { return Data + m_size; }

	/// @brief Checks if the first range [first1, last1) is lexicographically less than the second range [first2, last2).
	/// @param vec 
	/// @return lexicographical_compare
	bool operator< (const MAVector<T>& vec) {
		return (lexicographical_compare(this->begin(), this->end(), vec.begin(), vec.end()));
	}
	/// @brief operator overloading for > operator
	/// @param vec 
	/// @return apply < operator overloading 
	bool operator> (const MAVector<T>& vec) {
		return (vec < *this);
	}
	/// @brief operator overloading for == to compare 2 vectors
	/// @param vec 
	/// @return 1 if vec == this 
	bool operator==(const MAVector<T>& vec) {
		return (this->size() == vec.size() && std::equal(this->begin(), this->end(), vec.end()));
	}
	/// @brief operator overloading for << 
	/// @param out 
	/// @param vec 
	/// @return data[i]
	friend ostream& operator<<(ostream& out, const MAVector<T>& vec) {
		for (int i = 0; i < vec.size(); i++)
			out << vec.Data[i] << "\n";

		return out;
	}
};
